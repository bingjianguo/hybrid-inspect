'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_WEB_PORT = 8002; // port for web interface

var express = require('express'),
    url = require('url'),
    bodyParser = require('body-parser'),
    fs = require('fs'),
    path = require('path'),
    events = require('events'),
    qrCode = require('qrcode-npm'),
    util = require('./util'),
    certMgr = require('./certMgr'),
    wsServer = require('./wsServer'),
    juicer = require('juicer'),
    ip = require('ip'),
    co = require('co'),
    compress = require('compression');

var packageJson = require('../package.json');

var MAX_CONTENT_SIZE = 1024 * 2000; // 2000kb
/**
 *
 *
 * @class webInterface
 * @extends {events.EventEmitter}
 */

var webInterface = function (_events$EventEmitter) {
  (0, _inherits3.default)(webInterface, _events$EventEmitter);

  /**
   * Creates an instance of webInterface.
   *
   * @param {object} config
   * @param {number} config.webPort
   * @param {number} config.wsPort
   * @param {object} recorder
   *
   * @memberOf webInterface
   */
  function webInterface(config, recorder) {
    (0, _classCallCheck3.default)(this, webInterface);

    if (!recorder) {
      throw new Error('recorder is required for web interface');
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (webInterface.__proto__ || Object.getPrototypeOf(webInterface)).call(this));

    var self = _this;
    self.webPort = config.webPort || DEFAULT_WEB_PORT;
    self.recorder = recorder;
    self.config = config || {};

    self.app = null;
    self.server = null;
    self.wsServer = null;
    return _this;
  }

  (0, _createClass3.default)(webInterface, [{
    key: 'start',
    value: function start() {
      var self = this;
      var recorder = self.recorder;
      var wsPort = void 0;

      return co( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!self.config.wsPort) {
                  _context.next = 4;
                  break;
                }

                _context.t0 = self.config.wsPort;
                _context.next = 7;
                break;

              case 4:
                _context.next = 6;
                return util.getFreePort();

              case 6:
                _context.t0 = _context.sent;

              case 7:
                wsPort = _context.t0;

              case 8:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      })).then(function () {
        var ipAddress = ip.address(),

        // userRule = proxyInstance.proxyRule,
        webBasePath = 'web';
        var ruleSummary = '';
        var customMenu = [];

        try {
          ruleSummary = ''; //userRule.summary();
          customMenu = ''; // userRule._getCustomMenu();
        } catch (e) {}

        var myAbsAddress = 'http://' + ipAddress + ':' + self.webPort + '/',
            staticDir = path.join(__dirname, '../', webBasePath);

        var app = express();
        app.use(compress()); //invoke gzip
        app.use(function (req, res, next) {
          res.setHeader('note', 'THIS IS A REQUEST FROM ANYPROXY WEB INTERFACE');
          return next();
        });
        app.use(bodyParser.json());

        app.get('/latestLog', function (req, res) {
          res.setHeader('Access-Control-Allow-Origin', '*');
          recorder.getRecords(null, 10000, function (err, docs) {
            if (err) {
              res.end(err.toString());
            } else {
              res.json(docs);
            }
          });
        });

        app.get('/downloadBody', function (req, res) {
          var query = req.query;
          recorder.getDecodedBody(query.id, function (err, result) {
            if (err || !result || !result.content) {
              res.json({});
            } else if (result.mime) {
              if (query.raw === 'true') {
                //TODO : cache query result
                res.type(result.mime).end(result.content);
              } else if (query.download === 'true') {
                res.setHeader('Content-disposition', 'attachment; filename=' + result.fileName);
                res.setHeader('Content-type', result.mime);
                res.end(result.content);
              }
            } else {
              res.json({});
            }
          });
        });

        app.get('/fetchBody', function (req, res) {
          res.setHeader('Access-Control-Allow-Origin', '*');
          var query = req.query;
          if (query && query.id) {
            recorder.getDecodedBody(query.id, function (err, result) {
              // 返回下载信息
              var _resDownload = function _resDownload() {
                var isDownload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

                res.json({
                  id: query.id,
                  type: result.type,
                  fileName: result.fileName,
                  ref: '/downloadBody?id=' + query.id + '&download=' + isDownload + '&raw=' + !isDownload
                });
              };

              // 返回内容
              var _resContent = function _resContent() {
                if (util.getByteSize(result.content || '') > MAX_CONTENT_SIZE) {
                  _resDownload(true);
                  return;
                }

                res.json({
                  id: query.id,
                  type: result.type,
                  resBody: result.content
                });
              };

              if (err || !result) {
                res.json({});
              } else if (result.statusCode === 200 && result.mime) {
                if (result.type === 'json' || result.mime.indexOf('text') === 0 ||
                // deal with 'application/x-javascript' and 'application/javascript'
                result.mime.indexOf('javascript') > -1) {
                  _resContent();
                } else if (result.type === 'image') {
                  _resDownload(false);
                } else {
                  _resDownload(true);
                }
              } else {
                _resContent();
              }
            });
          } else {
            res.end({});
          }
        });

        app.get('/fetchCrtFile', function (req, res) {
          res.setHeader('Access-Control-Allow-Origin', '*');
          var _crtFilePath = certMgr.getRootCAFilePath();
          if (_crtFilePath) {
            res.setHeader('Content-Type', 'application/x-x509-ca-cert');
            res.setHeader('Content-Disposition', 'attachment; filename="rootCA.crt"');
            res.end(fs.readFileSync(_crtFilePath, { encoding: null }));
          } else {
            res.setHeader('Content-Type', 'text/html');
            res.end('can not file rootCA ,plase use <strong>anyproxy --root</strong> to generate one');
          }
        });

        //make qr code
        app.get('/qr', function (req, res) {
          res.setHeader('Access-Control-Allow-Origin', '*');
          var qr = qrCode.qrcode(4, 'M'),
              targetUrl = myAbsAddress;
          qr.addData(targetUrl);
          qr.make();
          var qrImageTag = qr.createImgTag(4);
          var resDom = '<a href="__url"> __img <br> click or scan qr code to start client </a>'.replace(/__url/, targetUrl).replace(/__img/, qrImageTag);
          res.setHeader('Content-Type', 'text/html');
          res.end(resDom);
        });

        app.get('/api/getQrCode', function (req, res) {
          res.setHeader('Access-Control-Allow-Origin', '*');
          var qr = qrCode.qrcode(4, 'M'),
              targetUrl = myAbsAddress + 'fetchCrtFile';

          qr.addData(targetUrl);
          qr.make();
          var qrImageTag = qr.createImgTag(4);

          // resDom = '<a href="__url"> __img <br> click or scan qr code to download rootCA.crt </a>'.replace(/__url/,targetUrl).replace(/__img/,qrImageTag);
          // res.setHeader("Content-Type", "text/html");
          // res.end(resDom);

          var isRootCAFileExists = certMgr.isRootCAFileExists();
          res.json({
            status: 'success',
            url: targetUrl,
            isRootCAFileExists: isRootCAFileExists,
            qrImgDom: qrImageTag
          });
        });

        // response init data
        app.get('/api/getInitData', function (req, res) {
          res.setHeader('Access-Control-Allow-Origin', '*');
          var rootCAExists = certMgr.isRootCAFileExists();
          var rootDirPath = certMgr.getRootDirPath();
          var interceptFlag = false; //proxyInstance.getInterceptFlag(); TODO
          var globalProxyFlag = false; // TODO: proxyInstance.getGlobalProxyFlag();
          res.json({
            status: 'success',
            rootCAExists: rootCAExists,
            rootCADirPath: rootDirPath,
            currentInterceptFlag: interceptFlag,
            currentGlobalProxyFlag: globalProxyFlag,
            ruleSummary: ruleSummary || '',
            ipAddress: util.getAllIpAddress(),
            port: '', //proxyInstance.proxyPort, // TODO
            wsPort: wsPort,
            appVersion: packageJson.version
          });
        });

        app.post('/api/generateRootCA', function (req, res) {
          res.setHeader('Access-Control-Allow-Origin', '*');
          var rootExists = certMgr.isRootCAFileExists();
          if (!rootExists) {
            certMgr.generateRootCA(function () {
              res.json({
                status: 'success',
                code: 'done'
              });
            });
          } else {
            res.json({
              status: 'success',
              code: 'root_ca_exists'
            });
          }
        });

        // should not be available in in-build version
        // app.post('/api/toggleInterceptHttps', (req, res) => {
        //   const rootExists = certMgr.isRootCAFileExists();
        //   if (!rootExists) {
        //     certMgr.generateRootCA(() => {
        //       proxyInstance.setIntercept(req.body.flag);
        //       // Also inform the web if RootCa exists
        //       res.json({
        //         status: 'success',
        //         rootExists
        //       });
        //     });
        //   } else {
        //     proxyInstance.setIntercept(req.body.flag);
        //     res.json({
        //       status: 'success',
        //       rootExists
        //     });
        //   }
        // });

        // app.post('/api/toggleGlobalProxy', (req, res) => {
        //   const flag = req.body.flag;
        //   let result = {};
        //   result = flag ? proxyInstance.enableGlobalProxy() : proxyInstance.disableGlobalProxy();

        //   if (result.status) {
        //     res.json({
        //       status: 'failed',
        //       errorMsg: result.stdout
        //     });
        //   } else {
        //     res.json({
        //       status: 'success',
        //       isWindows: /^win/.test(process.platform)
        //     });
        //   }
        // });

        app.use(function (req, res, next) {
          var indexTpl = fs.readFileSync(path.join(staticDir, '/index.html'), { encoding: 'utf8' }),
              opt = {
            rule: ruleSummary || '',
            customMenu: customMenu || [],
            wsPort: wsPort,
            ipAddress: ipAddress || '127.0.0.1'
          };

          if (url.parse(req.url).pathname === '/') {
            res.setHeader('Content-Type', 'text/html');
            res.end(juicer(indexTpl, opt));
          } else {
            next();
          }
        });

        app.use(express.static(staticDir));

        //plugin from rule file
        var server = app.listen(self.webPort);

        self.app = app;
        self.server = server;
      }).then(function () {
        // start ws server
        self.wsServer = new wsServer({
          port: wsPort
        }, recorder);

        return self.wsServer.start();
      });
    }
  }, {
    key: 'close',
    value: function close() {
      this.server && this.server.close();
      this.wsServer && this.wsServer.closeAll();

      this.server = null;
      this.wsServer = null;
      this.proxyInstance = null;
    }
  }]);
  return webInterface;
}(events.EventEmitter);

module.exports = webInterface;